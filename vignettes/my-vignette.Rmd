---
title: "my-vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{my-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    fig.height = 7,
    fig.width = 12
)
```

```{r setup}
library(Damsel)
```

# 1. Introduction

This document gives an introduction to the R package Damsel, for use in DamID analysis; from BAM file input to gene ontology analysis.

Designed for use with DamID data, the Damsel methodology could be modified for use on any similar technology that seeks to identify enriched regions relative to a control sample. 

Utilising the power of edgeR for differential analysis and goseq for gene ontology bias correction, Damsel provides a unique end to end analysis for DamID.

# Installation
```{r eval=FALSE}
BiocManager::install("Oshlack/Damsel", force = TRUE)
library(Damsel)
```


# 2. Processing the BAM files

As a DamID analysis tool, Damsel requires a GATC region file for analysis. These regions serve as a guide to extract counts from the BAM files.

## 2.1 Introducing the GATC region file


It can be generated with `gatc_region_fn()` using a `BSGenome` object or a FASTA file.


It is a `data.frame` with the consecutive GATC regions across the genome - representing the region (or the length) between GATC sites.

If you have another species of DamID data or would prefer to make your own region file, you can use the following function, providing a BSgenome object or a FASTA file.

```{r}
library(BSgenome.Dmelanogaster.UCSC.dm6)
regions_and_sites <- gatc_region_fn(BSgenome.Dmelanogaster.UCSC.dm6)
regions <- regions_and_sites$regions
knitr::kable(head(regions))
```
If you already have your own GATC region file, ensure that it has the same format as `regions_gatc_drosophila_dm6` with 6 columns: 

* Position: chromosome-start
* seqnames: chromosome name
* start: start of region
* end: end of region
* width: length of region (ensure that is is correct according to `[plyranges::as_granges()])`

The GATC regions are not evenly distributed across the genome, and vary greatly in size. 
This can be explored in more detail via boxplots 

```{r region boxplot, fig.height=5, fig.width=5}
ggplot2::ggplot(
    regions,
    ggplot2::aes(x = seqnames, y = log(width))
) +
    ggplot2::geom_boxplot()
```


## 2.2 Extracting the counts within the GATC regions

Note: Damsel requires BAM files that have been mapped to the reference genome.

Provided the path to a folder of BAM files (and their .bai files) and the appropriate GATC region file, the function `process_bams()` will extract the counts for each region for each available BAM and add them as columns to a data frame. The columns will be named by the BAM file name - please rename them before running `process_bams` if they do not make sense.

* the function makes use of `[exomeCopy::countBaminGranges()]`

```{r eval=FALSE}
path_to_bams <- system.file("extdata", package = "Damsel")
counts.df <- process_bams(path_to_bams,
    regions = regions
)
```
```{r include=FALSE}
data_env <- new.env(parent = emptyenv())
data("dros_counts", envir = data_env, package = "Damsel")
counts.df <- data_env[["dros_counts"]]
```

* If necessary, at this stage please rearrange the BAM file columns so they are ordered in the following way: Dam_1, Fusion_1, Dam_2, Fusion_2 etc
```{r}
knitr::kable(head(counts.df))
```
This is also available as a counts file through `data`.
```{r eval=FALSE}
data("dros_counts")
```

* Do not remove the .bam extension on the column names as this is used as a check in later functions to ensure only the BAM files are selected from the data frame.

* The DamID data captures the ~75bp region extending from each GATC site, so although regions are of differing widths, there is a null to minimal length bias present on the data, and does not require length correction.


## 2.3 Correlation analysis of samples

At this stage, the similarities and differences between the samples can be analysed via correlation.
 `corr_heatmap` plots the correlation of all available BAM files Dam and Fusion, to visualise the similarity between files.
The default for all Damsel correlation analysis is the non-parametric "spearman's" correlation.
The correlation between Dam_1 and Fusion_1 can be expected to reach ~ 0.7, whereas the correlation between Dam_1 & Dam_3 or Fusion_1 & Fusion_2 would be expected to be closer to ~0.9

```{r heatmap, fig.height=6, fig.width=6}
corr_heatmap(df = counts.df, method = "spearman")
```

Two specific samples can also be compared using `ggscatter` which plots a scatterplot of the two samples, overlaid with the correlation results. [ggpubr::ggscatter()]


## 2.4 Visualisation of coverage

A specific region can be selected to view the counts across samples.

```{r coverage, fig.height=7, fig.width=10}
plot_counts_all_bams(counts.df,
    seqnames = "chr2L",
    start_region = 1,
    end_region = 40000,
    log2_scale = FALSE,
    layout = "stacked"
)
```


```{r coverage2, fig.height=7, fig.width=10}
plot_counts_all_bams(counts.df,
    seqnames = "chr2L",
    start_region = 1,
    end_region = 40000,
    layout = "stacked",
    log2_scale = TRUE
)
```

```{r coverage3, fig.height=7, fig.width=10}
plot_counts_all_bams(counts.df,
    seqnames = "chr2L",
    start_region = 1,
    end_region = 40000,
    layout = "spread"
)
```


```{r coverage4, fig.height=7, fig.width=10}
plot_counts_all_bams(counts.df,
    seqnames = "chr2L",
    start_region = 1,
    end_region = 40000,
    layout = "spread",
    log2_scale = TRUE
)
```

# 3. Differential methylation analysis

The goal with DamID analysis is to identify regions that are enriched in the fusion sample relative to the control. In Damsel, this step is referred to as differential methylation analysis, and makes use of [edgeR].

For ease of use, Damsel has four main edgeR based functions which compile different steps and functions from within edgeR. 

## 3.1 Setting up edgeR analysis

`edgeR_set_up` sets up the edgeR analysis for differential methylation testing. Taking the data frame of samples and regions as input, it conducts the following steps:

* it extracts the sample data
* groups the samples (Dam or Fusion)
* filters the samples (remove regions with very low counts, the filtering parameters may be adjusted)
* normalises the data
* establishes the design matrix (this includes the sample group and pairing replicates together - Dam_1 & Fusion_1)
* estimates the dispersion

```{r}
dge <- edgeR_set_up(counts.df)
head(dge)
```

The output from this step is a DGEList containing all of the information from the steps.


## 3.2 Examining the data - multidimensional scaling plot

It's important to visualise the differences between the samples. This can be done with `edgeR_plot_mds`

You would expect the Dam samples to cluster together, and for the Fusion samples to cluster together.
You would expect the majority of the variation to be within the 1st dimension (the x axis), and less variation in the 2nd dimension (y axis)

```{r mds, fig.height=6, fig.width=6}
edgeR_plot_mds(dge)
```


## 3.3 Identifying differentially methylated regions

After exploring the data visually, it's time to identify the enriched regions. `edgeR_results` compiles the edgeR functions for differential testing with one key modification - it outputs the results with the adjusted p values as well as the raw p values.

`edgeR_results` conducts the following key steps:

* i. fits a QLF model - quasi likelihood
* ii. tests the model 
* iii. conducts p value adjustment and summarises model results by setting regions as either (1,0,-1) (log fold change and p value thresholds can be adjusted)

These results are incorporated with the region data, providing a result for every region. The regions excluded from edgeR analysis are given logFC = 0, and adjust.p = 1


```{r}
dm_results <- edgeR_results(dge, p.value = 0.01, lfc = 1, regions = regions)
dm_results %>% dplyr::group_by(meth_status) %>% dplyr::summarise(n = dplyr::n())

knitr::kable(head(dm_results), digits=32)
```


## 3.4 Plotting the results

The results from the above differential methylation analysis can be visualised in an MA style plot with `edgeR_results_plot`
MA style scatter plot with average logCPM on x-axis, average logFC on y-axis, with dots coloured by significance

```{r ma, fig.height=6, fig.width=8}
edgeR_results_plot(dge, p.value = 0.01, lfc = 1)
```

The edgeR results can be plotted alongside the counts as well.

```{r, fig.height=8, fig.width=10}
plot_counts_all_bams(counts.df,
    seqnames = "chr2L",
    start_region = 1,
    end_region = 40000,
    log2_scale = FALSE
) +
    geom_dm.res.lfc(dm_results.df = dm_results)
```

Only regions that are fully contained within the provided boundaries will be plotted.

* Add GATC sites

```{r}
gatc_sites <- regions_and_sites$sites

knitr::kable(head(gatc_sites))
```

```{r, fig.height=9, fig.width=10}
plot_counts_all_bams(counts.df,
    seqnames = "chr2L",
    start_region = 1,
    end_region = 40000,
    log2_scale = FALSE
) +
    geom_dm.res.lfc(dm_results) +
    geom_gatc(gatc_sites)
```



# 4. Identifying peaks (bridges)

As you could see from the plot of the differential methylation results, there are 10s of 1000s of enriched regions. To reduce the scale of this data to something that can be more biologically meaningul, enriched regions can be compiled into peaks.

## Aggregating the regions

Damsel identifies peaks by aggregating regions of enrichment. As DamID sequencing generally sequences the 75 bp from the GATC site, regions smaller than 150 bp are mostly non-significant in statistical testing. Because of this, gaps between peaks of less than or equal to 150 bp are combined into one longer peak.

Peaks are ranked by their mean p value - with regions that were excluded from edgeR analysis for being too small given a p value of 1.

Given that we know that Dam can methylate up to 5kb away, and most significantly within 1 kb, then peaks less than 2kb are considered "tightly bound",  2 kb < peaks < 10kb "bound", and peaks > 10kb "unexpected".

```{r}
peaks <- aggregate_peaks(dm_results)
nrow(peaks)

knitr::kable(head(peaks), format = "html", table.attr = "style='width:30%;'", digits = 32)
```
### A new peak function
I've made a new peak function, this one is more stringent and identifies less peaks
```{r}
peaks2 <- new_peaks_fn(dm_results)
nrow(peaks2)

knitr::kable(head(peaks2), format = "html", table.attr = "style='width:30%;'", digits = 32)
```
### Comparison of the 2 approaches
```{r}
plyranges::find_overlaps(plyranges::as_granges(peaks), plyranges::as_granges(peaks2))
#number of distinct peaks (aggregate_peaks)
plyranges::find_overlaps(plyranges::as_granges(peaks), plyranges::as_granges(peaks2)) %>% 
  data.frame() %>% dplyr::distinct(peak_id.x) %>% nrow()
#number of distinct peaks (new_peaks_fn)
plyranges::find_overlaps(plyranges::as_granges(peaks), plyranges::as_granges(peaks2)) %>% 
  data.frame() %>% dplyr::distinct(peak_id.y) %>% nrow()
```
The majority of the new peaks overlap with the original peak function: 1140/1165 (98% overlap)
However, the original peak function does find a lot more 1145/1766 (65% overlap)

## Plotting

A peak plot layer can be added to our graph

```{r, fig.height=8, fig.width=10}
plot_counts_all_bams(counts.df,
    seqnames = "chr2L",
    start_region = 1,
    end_region = 40000
) +
    geom_dm.res.lfc(dm_results) +
    geom_peak.new(peaks) +
    geom_gatc(gatc_sites)
```

```{r, fig.height=8, fig.width=10}
plot_counts_all_bams(counts.df,
    seqnames = "chr2L",
    start_region = 1,
    end_region = 40000
) +
    geom_dm.res.lfc(dm_results) +
    geom_peak.new(peaks, peak.label = TRUE) +
    geom_gatc(gatc_sites)
```

# 5. Identifying genes associated with peaks

The peak information itself - while interesting, has no biological meaning. As the peaks represent a region that the Fusion protein interacted with on the DNA, likely as a transcription factor, we wish to identify the gene that is being affected. To do so, we need to associate the peaks with a potential "target" gene.

Note: any gene identified here is only a potential target that must be validated in laboratory procedures. There is no method available that is able to accurately predict the location and target genes of enhancers, so a key and potentially incorrect assumption in this part of the analysis is that all peaks represent binding to a local enhancer or promoter - that it is close or overlapping to the target gene.

It must also be noted that the Drosophila melanogaster genome and transcription factor interactions are different to that of mammals and using the same assumptions means results must be taken cautiously. While mammalian genes are generally spread out with little overlap, there is a large amount of overlap between Drosophila genes, requiring some intuitive interpretation of which gene the peak is potentially targeting.

In the Damsel methodology, peaks are considered to associate with genes if they are within 5kb upstream or downstream. If multiple genes are within these criteria, they are all listed, with the closest gene given the primary position.

## 5.1 Extract genes 

Obtaining information about the genes is done through accessing Ensembl via biomaRt. As this can be a slow process, it has been provided for Drosophila melanogaster dm6 and can be loaded via `data`.

Functions to undertake this are also available (`get_biomart_genes`), and follow these general steps:

* accesses biomaRt using the seqnames of the appropriate GATC region file as a guide
* accesses biomaRt a second time to obtain only the Ensembl canonical sequence information for each gene
* identifies the number of GATC regions that overlap with each gene

The below function has been deprecated
```{r eval=FALSE}
genes <- get_biomart_genes(
    species = "dmelanogaster_gene_ensembl",
    version = 109,
    regions = regions
)
```
And has been replaced by the new function collateGenes
This function removes the dependency on biomaRt, by allowing for a TxDb library of biomaRt query as input
A TxDb package is available for most species and has information about the genes, exons, cds, promoters, etc - which can all be accessed using the GenomicFeatures package.
This presentation has a lot of slides on how to use TxDb objects to access different data types: https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/GenomicFeatures_In_Bioconductor.html#10

However, TxDb libraries contain only the Ensembl gene Ids and not the gene symbol or name. Instead we need to access an org.Db package to transfer them over. org.Db packages contain information about model organisms genome annotation, and can be used to extract various information about the gene name etc. More information can be found here
https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/GenomicFeatures_In_Bioconductor.html#46
```{r eval=FALSE}
BiocManager::install("TxDb.Dmelanogaster.UCSC.dm6.ensGene")
BiocManager::install("org.Dm.eg.db")
```

```{r}
library("TxDb.Dmelanogaster.UCSC.dm6.ensGene")
txdb <- TxDb.Dmelanogaster.UCSC.dm6.ensGene::TxDb.Dmelanogaster.UCSC.dm6.ensGene
library("org.Dm.eg.db")
genes <- collateGenes(genes=txdb, regions=regions, org.Db=org.Dm.eg.db)
knitr::kable(head(genes))
```
Alternatively, the name of a species listed in biomaRt can be provided, and the version of the genome. A guide to understanding more about how biomaRt functions is here: https://bioconductor.org/packages/release/bioc/vignettes/biomaRt/inst/doc/accessing_ensembl.html
```{r eval=FALSE}
BiocManager::install("biomaRt")
```
```{r}
library(biomaRt)
collateGenes(genes = "dmelanogaster_gene_ensembl", regions=regions, version = 109)
```

## 5.2 Annotating genes to peaks

As stated above, Damsel associates genes with peaks if they are within 5 kb upstream or downstream. This maximum distance is an adjustable parameter within the `annotate_genes()` function. If set to `NULL` it will output all possible combinations as defined by `plyranges::pair_nearest`. The nature of this function means that the closest gene will be found for every peak, even if that distance is in the millions. If the user sets `max_distance=NULL`, we recommend undergoing some filtering to remove those associations.

To respect that some species have genes with more overlap than others, `annotate_genes` outputs a list of data frames. The first, closest, outputs information for every peak and it's closest gene. The second data frame, top_five, outputs a string of the top five genes (if available) and their distances from each peak. The final data frame, all, provides the raw results and all possible gene and peak associations, as well as all available statistical results.

```{r}
annotation <- annotate_genes(peaks, genes, regions = regions, max_distance = 5000)

knitr::kable(head(annotation$closest), digits=32)
knitr::kable(head(annotation$top_five), digits=32)
knitr::kable(str(annotation$all), digits=32)
```



## 5.4 Interpreting results/Plotting

Now that we have the genes from `get_biomart_genes()`, this can be added as a layer to the previous plots. This plot requires the gene positions as a guide for a `Txdb` or `EnsDb` object, building off the autoplot generic built by `ggbio`.

```{r, fig.height=9, fig.width=10}
plot_counts_all_bams(counts.df, 
                     seqnames = "chr2L",
                     start_region = 1, 
                     end_region = 40000) +
  geom_dm.res.lfc(dm_results) +
  geom_peak.new(peaks) +
  geom_gatc(gatc_sites) +
  geom_genes.me(genes, txdb)
```


* If the scale of the gene plot is disproportional to the height of the overall plot - if it is too large or too squished, it can be adjusted using the `plot.height` argument.

```{r, fig.height=9, fig.width=10}
plot_wrap(id = peaks[1,]$peak_id, 
          counts.df = counts.df, 
          dm_results.df = dm_results, 
          peaks.df = peaks, 
          gatc_sites.df = gatc_sites, 
          genes.df = genes, txdb = txdb)
```

```{r, fig.height=9, fig.width=10}
plot_wrap(id = genes[1,]$ensembl_gene_id, 
          counts.df = counts.df, 
          dm_results.df = dm_results, 
          peaks.df = peaks, 
          gatc_sites.df = gatc_sites, 
          genes.df = genes, txdb = txdb)
```


# 6. Gene ontology 
One of the last steps in a typical DamID analysis is gene ontology analysis. However, a key mistake made in this analysis using any common data type - including RNA-seq, is the lack of bias correction. We correct for this by utilising the [goseq] package.

## 6.1 GO analysis with goseq
`goseq_fn` identifies the top 10 over-represented GO terms from the peak data, correcting for the number of GATC regions matching to each gene.
 
Outputs list of 4 graphs
List of top 10 over-represented GO terms across the 3 GO categories
Plot of goodness of fit of model
Plot of sample data
Plot of sample data without bias correction (should be messy)

```{r}
ontology <- goseq_fn(annotation$all, genes, regions=regions, extend_by=2000)

knitr::kable(head(ontology$signif_results), digits=32)
knitr::kable(head(ontology$prob_weights), digits=32)
```


```{r, fig.height=9, fig.width=10}
plot_gene_ontology(ontology$signif_results, plot_type = "bar", bar_x = "gene_ratio")
```


```{r, fig.height=9, fig.width=10}
plot_gene_ontology(ontology$signif_results, plot_type = "dot")
```


# Appendix
```{r}
sessionInfo()
```

